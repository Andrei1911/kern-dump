from defcon import Font
import re, sys, os, time


class UFOkernData(object):
	def __init__(self, font):
		self.font = Font(font)

		## kerning lists for pairs only
		self.group_group = []
		self.glyph_glyph = []
		self.glyph_group = []
		self.group_glyph = []

		# kerning dicts that will contain pair-value combinations
		self.glyph_glyph_dict = {}
		self.glyph_glyph_exceptions_dict = {}
		self.glyph_group_dict = {}
		self.glyph_group_exceptions_dict = {}
		self.group_glyph_dict = {}
		self.group_glyph_exceptions_dict = {}
		self.group_group_dict = {}		

		self.gl2gr = {}
		self.timestring = time.strftime("%A, %B %d, %Y %H:%M:%S", time.localtime())
		self.output = ['# First Class Kerning Data Generated by %s' % os.path.basename(__file__), '# Created: %s' % self.timestring, '# Font Name: %s' % self.font.info.postscriptFullName, ''] 

	def isGroup(self, name):
		if name[0] == '@':
			return True
		else:
			return False
		
	def getFlag(self, groupName):
		'Assuming MetricsMachine group names, this returns either L or R; representing the side of the group.'
		if groupName in self.font.groups.keys():
			return groupName.split('_')[1]
	
	
	def getWritingSystem(self, groupName):
		wSystem = None
		for i in groupName.split('_'):
			if re.match(r'(LAT|GRK|CYR)', i):
				wSystem = i
				break
		return wSystem
	
	
	def getCase(self, groupName):
		case = None
		for i in groupName.split('_'):
			if len(i) > 1:
				if re.match(r'(UC|LC)', i):
						case = i
		return case
	
	
	def getKeyGlyph(self, groupName):
		if groupName in self.font.groups.keys():
			if self.alt_mode: # For groups named 'LAT_LC_a', 'CYR_LC_a.cyr' etc.
	
				if groupName.split('_')[-1] in self.font.groups[groupName]:
					keyGlyph = '%s' % groupName.split('_')[-1]
				elif '%s_%s' % (groupName.split('_')[-2], groupName.split('_')[-1]) in self.font.groups[groupName]: # ligatures
					keyGlyph = '%s_%s' % (groupName.split('_')[-2], groupName.split('_')[-1])
				elif '%s_%s_%s' % (groupName.split('_')[-3], groupName.split('_')[-2], groupName.split('_')[-1]) in self.font.groups[groupName]: # ligatures
					keyGlyph = '%s_%s_%s' % (groupName.split('_')[-3], groupName.split('_')[-2], groupName.split('_')[-1])
				else:
					keyGlyph = self.font.groups[groupName][0]
	
			else: # For groups named 'I', 'I_LC', 'S_LC_LEFT_LAT' etc.
				# assuming Metrics Machine-built group names:
				glyph = groupName.split('_')[2]
	
	 			if glyph in self.font.groups[groupName]:
	 				keyGlyph = '%s' % glyph
	 			elif glyph.lower() in self.font.groups[groupName]:
	 				keyGlyph = '%s' % glyph.lower()
				elif '%s.%s' % (groupName.split('_')[-2], groupName.split('_')[-1].lower()) in self.font.groups[groupName]: # small caps or alternates
					keyGlyph = '%s.%s' % (groupName.split('_')[-2], groupName.split('_')[-1].lower())

				# ligature crap - omitted
				# elif '%s_%s' % (groupName.split('_')[-2], groupName.split('_')[-1]) in self.font.groups[groupName]: # ligatures
				# 	keyGlyph = '%s_%s' % (groupName.split('_')[-2], groupName.split('_')[-1])
				# elif '%s_%s_%s' % (groupName.split('_')[-3], groupName.split('_')[-2], groupName.split('_')[-1]) in self.font.groups[groupName]: # ligatures
				# 	keyGlyph = '%s_%s_%s' % (groupName.split('_')[-3], groupName.split('_')[-2], groupName.split('_')[-1])
	
				else:
					keyGlyph = self.font.groups[groupName][0]

		return keyGlyph
	
	
	def getOtherGlyphs(self, groupName):
		'Get all the glyphs in a class, except the keyglyph.'
		li = []
		if groupName in self.font.groups.keys():
			li.extend(self.font.groups[groupName])
			li.remove(self.getKeyGlyph(groupName))
			return sorted(li)
	
	
	def adobeName(self, groupName):
		# return groupName
		'Changes the Metrics Machine class name to match Adobe-style class naming'
		if self.getFlag(groupName) == 'L':
			flag = 'LEFT'
		else: flag = 'RIGHT'
	
		name = '@%s' % self.getKeyGlyph(groupName)
	
		if self.getCase(groupName):
			name += '_%s' % self.getCase(groupName)
	
		name += '_%s' % flag
	
		if self.getWritingSystem(groupName):
			name += '_%s' % self.getWritingSystem(groupName)
	
		return name
	
	
	def dict2pos(self, dictionary):
		'Turns a dictionary to a list of kerning pairs'
		data = []
		for i in dictionary:
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (True, False):
				data.append( 'pos %s %s %s;' % (self.adobeName(i[0]), i[1], dictionary[i]) )
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (False, True):
				data.append( 'pos %s %s %s;' % (i[0], self.adobeName(i[1]), dictionary[i]) )
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (True, True):
				data.append( 'pos %s %s %s;' % (self.adobeName(i[0]), self.adobeName(i[1]), dictionary[i]) )
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (False, False):
				data.append( 'pos %s %s;' % (' '.join(i), dictionary[i]) )
		return '\n'.join(sorted(data))
	
	
	def dict2enumpos(self, dictionary):
		'Turns a dictionary to a list of enum kerning pairs (for glyph_class/class_glyph exceptions )'
		data = []
		for i in dictionary:
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (True, False):
				data.append( 'enum pos %s %s %s;' % (self.adobeName(i[0]), i[1], dictionary[i]) )
			if (self.isGroup(i[0]), self.isGroup(i[1])) == (False, True):
				data.append( 'enum pos %s %s %s;' % (i[0], self.adobeName(i[1]), dictionary[i]) )
		return '\n'.join(sorted(data))
	

	def makegl2gr(self):
		'Creates a glyph-to-group dict to identify which glyphs are in a kerning class; and which classes those are.'
		# This is an issue!!! Change it!!!
		for i in self.font.groups.keys():
###			getFlag
			for glyph in self.font.groups[i]:
				if not glyph in self.gl2gr:
					self.gl2gr[glyph] = [i]
				else:
					self.gl2gr[glyph].append(i)
		for i in self.gl2gr:
			# sorting by left/right class (not really necessary, probably)
			self.gl2gr[i].sort()


	def do(self):
		self.makegl2gr()
	
		# filter the raw kerning pairs into glyph/glyph, glyph/group, group/glyph and group/group lists.
		for (left, right), value in sorted(self.font.kerning.items()):
		 	if self.isGroup(left):
		 		if self.isGroup(right):
		 			self.group_group.append((left, right))
		 		else:
		 			self.group_glyph.append((left, right))
		 	elif self.isGroup(right):
		 		if self.isGroup(left):
		 			self.group_group.append((left, right))
		 		else:
		 			self.glyph_group.append((left, right))
	 			
		 	else:
		 		self.glyph_glyph.append((left, right))
	 	
		if len(self.glyph_group) + len(self.glyph_glyph) + len(self.group_glyph) + len(self.group_group) != len(self.font.kerning): 
			print 'Something went wrong: kerning lists do not match the amount of kerning pairs present in the font.'
	
	
		# process lists to find out which pairs are exceptions, and which just are normal pairs.
		# glyph group
		for (g, gr) in self.glyph_group:
			group = self.font.groups[gr]
			if g in self.gl2gr:
				# it is a glyph_to_group exception!
				self.glyph_group_exceptions_dict[g, gr] = self.font.kerning[g, gr]
			else:
				for i in group:
					pair = (g, i)
					if pair in self.glyph_glyph:
						# that pair is a glyph_to_glyph exception!
						self.glyph_glyph_exceptions_dict[pair] = self.font.kerning[pair]
				else:
					# kerndict[g, group[0]] = self.font.kerning[g, gr]
					self.glyph_group_dict[g, gr] = self.font.kerning[g, gr]
	
	
		# group glyph
		for (gr, g) in self.group_glyph:
			group = self.font.groups[gr]
			if g in self.gl2gr:
				# it is a group_to_glyph exception!
				self.group_glyph_exceptions_dict[gr, g] = self.font.kerning[gr, g]
			else:
				for i in group:
					pair = (i, g)
					if pair in self.glyph_glyph:
						# that pair is a glyph_to_glyph exception!
						self.glyph_glyph_exceptions_dict[pair] = self.font.kerning[pair]
				else:
					# kerndict[group[0], g] = self.font.kerning[gr, g]
					self.group_glyph_dict[gr, g] = self.font.kerning[gr, g]
		
	
		# group group
		for (lgr, rgr) in self.group_group:
			lgroup = self.font.groups[lgr]
			rgroup = self.font.groups[rgr]
			for lg in lgroup:
				for rg in rgroup:
					pair = (lg, rg)
					if pair in self.glyph_glyph:
						# that pair is a glyph_to_glyph exception!
						self.glyph_glyph_exceptions_dict[pair] = self.font.kerning[pair]
			else:
				# kerndict[lgroup[0], rgroup[0]] = self.font.kerning[lgr, rgr]
				self.group_group_dict[lgr, rgr] = self.font.kerning[lgr, rgr]
	
	
		# glyph glyph
		for (lg, rg) in self.glyph_glyph:
			pair = (lg, rg)
			if not pair in self.glyph_glyph_exceptions_dict:
		 		# kerndict[pair] = self.font.kerning[pair]
				self.glyph_glyph_dict[pair] = self.font.kerning[pair]
	
	
		## figure which way the classes are named:
		self.alt_mode = False  # this switch is for the alternate mode, for groups named 'LAT_LC_a', 'CYR_LC_a.cyr' etc.
	
		rex = r'(LAT|CYR|GRK)_(LC|UC)'
		counter = 0
		for g in self.font.groups.keys():
			if re.search(rex, g): counter += 1
		if counter > len(self.font.groups.keys())/2:
			self.alt_mode = True
	
		# write out all the classes:
		for groupName, glyphList in sorted(self.font.groups.items()):
		#	print '%s = [%s];' % (adobeName(groupName), ' '.join(glyphList))
			if len(self.getOtherGlyphs(groupName)) == 0:
				self.output.append( '%s = [%s];' % (self.adobeName(groupName), self.getKeyGlyph(groupName)) )
			else:
				self.output.append( '%s = [%s %s];' % (self.adobeName(groupName), self.getKeyGlyph(groupName), ' '.join(self.getOtherGlyphs(groupName))) )
	
	
	
		if len(self.glyph_glyph_exceptions_dict):
			self.output.append( '\n# glyph, glyph exceptions:' )
			self.output.append( self.dict2pos(self.glyph_glyph_exceptions_dict) )
		if len(self.glyph_glyph_dict):
			self.output.append( '\n# glyph, glyph:' )
			self.output.append( self.dict2pos(self.glyph_glyph_dict) )
		if len(self.glyph_group_exceptions_dict):
			self.output.append( '\n# glyph, group exceptions:' )
			self.output.append( self.dict2enumpos(self.glyph_group_exceptions_dict) )
		if len(self.group_glyph_exceptions_dict):
			self.output.append( '\n# group, glyph exceptions:' )
			self.output.append( self.dict2enumpos(self.group_glyph_exceptions_dict) )
			
		if len(self.glyph_group_dict):
			self.output.append( '\n# glyph, group:' )
			self.output.append( self.dict2pos(self.glyph_group_dict) )
		if len(self.group_glyph_dict):
			self.output.append( '\n# group, glyph:' )
			self.output.append( self.dict2pos(self.group_glyph_dict) )
		if len(self.group_group_dict):
			self.output.append( '\n# group, group:' )
			self.output.append( self.dict2pos(self.group_group_dict) )
	

		# f = open("file", "w+")
		# f.write('\n'.join(self.output))
		# f.seek(0)
		# return f.readlines()
		# f.close()

		return '\n'.join(self.output)
	# def writeDataToFile(self):
	# 
	# 	kKernFeatureFileName = '%s.%s' % (kKernFeatureFileBaseName, 'kern')
	# 
	# 	print '\tSaving %s file...' % kKernFeatureFileName
	# 	if self.trimmedPairs > 0:
	# 		print '\tTrimmed pairs: %s' % self.trimmedPairs
	# 	
	# 	filePath = os.path.join(self.folder, kKernFeatureFileName)
	# 	outfile = open(filePath, 'w')
	# 	outfile.write('\n'.join(self.instanceFontInfo))
	# 	outfile.write('\n\n')
	# 	if len(self.OTkernClasses):
	# 		outfile.writelines(self.OTkernClasses)
	# 		outfile.write(self.lineBreak)
	# 	if len(self.allKernPairs):
	# 		outfile.writelines(self.allKernPairs)
	# 		outfile.write(self.lineBreak)
	# 	outfile.close()
	# 
	# 
